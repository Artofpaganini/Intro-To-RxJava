# Часть 2 - Основы последовательностей

Теперь, когда мы понимаем основные принципы Rx, настало время научиться создавать и управлять последовательностями. Стиль управления последовательностями был позаимствован у оригинального C# [LINQ](https://en.wikipedia.org/wiki/Language_Integrated_Query), который в свою очередь был вдохновлен функциональным программироанием. Мы поделим все операции по темам, которые отсортированы в порядке возрастания сложности операций. Большинство операторов Rx управляют уже существующими последовательностями, но для начала мы научимся их создавать.

# Создание последовательности

В прошлых примерах мы использовали `Subject`ы и вручную подавали на них значения чтобы создать последовательность. Мы делали так чтобы продемонстрировать некоторые ключевые моменты а главное, самый основной в Rx метод, `subscribe`. В большинстве случаев `Subject` это нелучший способ создать новый `Observable`. Сейчас мы рассмотрим более элегантные способы сделать это.

## Простые фабоичные методы

### Observable.just

`just` создает `Observable`, который выдаст определенное заранее кол-во значений, после чего завершится.

```java
Observable<String> values = Observable.just("one", "two", "three");
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);	
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
Received: one
Received: two
Received: three
Completed
```

### Observable.empty

This observable will emit a single onCompleted and nothing else.

Этот `Observable` выдаст только событие `onCompleted` и больше ничего.


```java
Observable<String> values = Observable.empty();
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
Completed
```

### Observable.never

Этот `Observable` никогда ничего не выдаст.

```java
Observable<String> values = Observable.never();
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```

Код [выше](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java) ничего не напечатает. Однако заметьте, что это не означает что программа блокируется. По-факту онапросто мгновенно завершится.

### Observable.error

Этот `Observable` выдаст событие onError и завершится.

```java
Observable<String> values = Observable.error(new Exception("Oops"));
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
Error: java.lang.Exception: Oops
```

### Observable.defer

`defer` не создает новый `Observable`, но позволяет определить каким образом `Observable` будет создан при появлении подписчиков. Подумайте как бы вы создали `Observable` который будет единажды выдавать текущее время. Так как значение только одно, похоже что здесь нам поможет `just`.

```java
Observable<Long> now = Observable.just(System.currentTimeMillis());

now.subscribe(System.out::println);
Thread.sleep(1000);
now.subscribe(System.out::println);
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
1431443908375
1431443908375
```

Обратите внимание как второй подписчик, подписавшись на секунду позже, получает такое же значение. Это происходит потому что значение времени было вычислено лишь единажды: когда выполнение доходит до метода `just`. Однако в нашем случае мы хотим вычислять текущее время при каждой подписке. `defer` принимает функцию, которая возвращает `Observable` и будет выполнена для каждого нового подписчика.

```java
Observable<Long> now = Observable.defer(() ->
		Observable.just(System.currentTimeMillis()));

now.subscribe(System.out::println);
Thread.sleep(1000);
now.subscribe(System.out::println);
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
1431444107854
1431444108858
```

### Observable.create

`create` это очень мощная функция для создания `Observable`. Посмотрим на ее сигнатуру.

```java
static <T> Observable<T> create(Observable.OnSubscribe<T> f)
```

Все намного проще чем выглядит. Это всего лишь функция, которая принимает `Subscriber` для типа `T`. Внутри него мы можем вручную определить события, которые будут выдаваться подписчику.

```java
Observable<String> values = Observable.create(o -> {
	o.onNext("Hello");
	o.onCompleted();
});
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/ObservableFactoriesExample.java)
```
Received: Hello
Completed
```

Когда кто-нибудь подпишется на наш `Observable` (в данном случае `values`), соответствующий экземпляр `Subscriber` будет передан в функцию `create`. По мере выполнения кода, значения будут переданы подписчику. Следует обратить внимание, что нужно самостоятельно вызывать метод `onCompleted` чтобы просигнализировать окончание последовательности.

Данный метод является рекомендуемым способом создания `Observable`, в случае если ни один из других способов не подходит. Это похоже на то, как мы создавали `Subject` и вручную подавали на него значения, однако есть несколько важных отличий. В первую очередь, источних событий аккуратно инкапсулирован и отделен от другого кода. Во-вторых, `Subject`ы имеют неочевидные опасности: с помошью `Subject` мы управляем состоянием, и любой кто имеет доступ к обьекту сможет изменить последовательность. Мы еще вернемся к этой проблеме позже.

Еще одним ключевым отличием от использования `Subject` является то, что код выполняется "lazily", только тогда когда прибывает новый подписчик. В примере выше, код выполняется _не_ в момент создания `Observable` (так как подписчиков еще нет), а в момент вызова метода `subscribe`. Это означает, что значения будет вычислены заново для каждого подписчика, как в `ReplaySubject`. Конечный результат похож на  `ReplaySubject`, за исключением кеширования. С помощью `ReplaySubject` нам приходилось бы вручную создавать отдельные потоки чтобы вычислять значения асинхронно, в то время как существуют более элегантные способы сделать выполнение метода `onSubscribe` параллельным.


Вы уже могли заметить что любой из предыдущих `Observable` можно реализовать при помощи `Observable.create`. Наш пример для `create` эквивалентен `Observable.just("hello")`.

## Functional unfolds

В функциональном программировании обычным делом является создание бесконечных последовательностей.

### Observable.range

Простой и знакомый функциональным программистам метод. Выдает значения из заданного диапазона.

```java
Observable<Integer> values = Observable.range(10, 15);
```

Этот [пример](/tests/java/itrx/chapter2/creating/FunctionalUnfoldsExample.java) последовательно выдает значения от 10 до 24.

### Observable.interval

Эта функция создаст _бесконечную_ последовательность тиков, отделенных заданным интервалом времени.

```java
Observable<Long> values = Observable.interval(1000, TimeUnit.MILLISECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
System.in.read();
```
[Вывод](/tests/java/itrx/chapter2/creating/FunctionalUnfoldsExample.java)
```
Received: 0
Received: 1
Received: 2
Received: 3
...
```

Последовательность не завершится до тех пор пока мы не отпишемся.

Следует обратить внимание почему блокирующий ввод в конце примера обязателен. Без него программа завершится ничего не напечатав. Это происходит потому, что все наши операции не являются блокирующими: мы создаем `Observable` который периодически выдает значения, затем регистрируем подписчика выполняющего некоторые действия в момент прибытия этих значений. Ничто из этого не блокирует главный поток от завершения. Таймер, который провоцирует события работает в отдельном потоке, который не мешает JVM завершить выполнение.

### Observable.timer

Существует две перегрузки `Observable.timer`. Первый вариант создает `Observable` выжидающий заданный промежуток времени, затем выдает `0L` и завершается.

```java
Observable<Long> values = Observable.timer(1, TimeUnit.SECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/FunctionalUnfoldsExample.java)
```
Received: 0
Completed
```
Второй вариант ожидает заданный промежуток времени, затем начинает выдавать значения так же как `interval` с заданной частотой.

```java
Observable<Long> values = Observable.timer(2, 1, TimeUnit.SECONDS);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/FunctionalUnfoldsExample.java)
```
Received: 0
Received: 1
Received: 2
...
```

Пример выше ждет 2 секунды, затем начинает считать каждую секунду.


## Transitioning into Observable

В java существуют инструменты для работы с последовательностями, коллекциями и асинхронными событиями, которые могут не иметь прямой совместимости с Rx. Сейчас мы рассмотрим каким образом можно превратить их во входящие данные вашего Rx кода.

Если вы используете EventHandler'ы, то с помощь `Observable.create` из событий можно создать последовательность.

```java
Observable<ActionEvent> events = Observable.create(o -> {
    button2.setOnAction(new EventHandler<ActionEvent>() {
        @Override public void handle(ActionEvent e) {
            o.onNext(e)
        }
    });
})
```

Depending on what the event is, the event type (here `ActionEvent`) may be meaningful enough to be the type of your sequence. Very often you will want something else, like the contents of a field. The place to get the value is in the handler, while the GUI thread is blocked by the handler and the field value is relevant. There is no guarantee what the value will be by the time the value reaches the final `Subscriber`. On the other hand, a value moving though an observable should remain unchanged, if the pipeline is properly implemented.

В зависимости от конкретного события, его тип (в данном случае `ActionEvent`) сам по себе может нести достаточно информации чтобы стать типом вашего `Observable`. Однако, очень часто вам может понадобиться что-нибудь другое, например, значение некого поля в момент события. Получить значение такого поля лучше всего внутри хендлера, пока UI поток заблокирован и значения поля актуально. И хотя не существует гарантий, что значение останется неизменным до достижения конечного подписчика, в правильно реализованном Rx коде такого обычно не происходит.

## Observable.from

Также как и с функциями выше, вы можете превратить любые входные данные в `Observable` при помощи `create`. Существуют удобные способы сделать это для распространенных типов данных.

`Future`'ы являются частью Java и вы должно быть сталкивались с ними во время работы с фреймворками, использующими многопоточность. Они являются менее мощным многопоточным инструментом чем Rx, так как возвращают лишь одно значение. Как правило, вы захотите превратить их в `Observable`.

```java
FutureTask<Integer> f = new FutureTask<Integer>(() -> {
	Thread.sleep(2000);
	return 21;
});
new Thread(f).start();

Observable<Integer> values = Observable.from(f);

Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/FromExample.java)
```
Received: 21
Completed
```

`Observable` выдает результат `FutureTask` как только таковой появляется, после чего завершается. Если задача была отменена, observable выдаст исключение `java.util.concurrent.CancellationException`.

Если вы заинтересованы в результате `Future` только ограниченное время, вы можете задать таймаут в качестве аргумента
```java
Observable<Integer> values = Observable.from(f, 1000, TimeUnit.MILLISECONDS);
```
Если за это время `Future` не завершится, observable проигнорирует результат и выдаст `TimeoutException`.

Существует возможность превратить любую коллекцию в последовательность при помощи перегруженных версий `Observable.from`. Таким образом будет создан `Observable`, который выдаст каждый элемент коллекции по-отдельности и `onCompleted` в конце.

```java
Integer[] is = {1,2,3};
Observable<Integer> values = Observable.from(is);
Subscription subscription = values.subscribe(
    v -> System.out.println("Received: " + v),
    e -> System.out.println("Error: " + e),
    () -> System.out.println("Completed")
);
```
[Вывод](/tests/java/itrx/chapter2/creating/FromExample.java)
```
Received: 1
Received: 2
Received: 3
Completed
```

`Observable` это не то же что `Iterable` или `Stream`. `Observable` push-ориентированный, в том смысле, что вызов `onNext` провоцирует стек обработчиков выполниться вплоть до последнего `subscribe` метода (если не задано иначе). Остальные модели pull-ориентированные - значения в них запрашиваются с другой стороны и выполнение блокируется до возвращения результата.

[Reducing a sequence](/Part 2 - Sequence Basics/2. Reducing a sequence.md) |

#### Continue reading

| Previous | Next |
| --- | --- |
| [Lifetime management](/Part 1 - Getting Started/3. Lifetime management.md) | 